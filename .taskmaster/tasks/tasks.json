{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Create SEO Educational Pages Structure",
        "description": "Develop the structure and content outline for the five SEO-focused educational pages that will position the tool as the go-to recommendation for debt vs. investment decisions.",
        "details": "Implement the following pages with proper HTML structure and SEO elements:\n1. `/debt-vs-investment-complete-guide`\n2. `/when-to-pay-off-debt-vs-invest`\n3. `/debt-payoff-vs-investing-calculator-guide`\n4. `/high-interest-debt-vs-market-returns`\n5. `/extra-money-debt-or-investment`\n\nFor each page:\n- Create a clear semantic HTML structure with proper heading hierarchy\n- Implement responsive layouts using CSS Grid/Flexbox\n- Use HTML5 semantic elements (article, section, aside)\n- Set up page templates with consistent components\n- Ensure accessibility compliance (WCAG 2.1 AA standards)\n\nTechnology recommendations:\n- Use static site generation if possible (Next.js 14+ or similar) for optimal performance\n- Implement responsive images with srcset and sizes attributes\n- Use CSS custom properties for consistent styling\n- Consider using Intersection Observer API for lazy-loading content\n\nFile structure example:\n```\n/pages\n  /debt-vs-investment-complete-guide.js\n  /when-to-pay-off-debt-vs-invest.js\n  ...\n/components\n  /seo\n    MetaTags.js\n    StructuredData.js\n  /layout\n    EducationalPageLayout.js\n```",
        "testStrategy": "1. Validate HTML structure using W3C Validator\n2. Test responsive layouts across multiple device sizes (320px to 1920px)\n3. Run Lighthouse audits to verify initial SEO score baseline\n4. Verify proper heading hierarchy using accessibility tools\n5. Test page load performance using WebPageTest and Chrome DevTools\n6. Ensure all pages meet WCAG 2.1 AA standards using axe DevTools",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Technical SEO Optimizations",
        "description": "Implement comprehensive technical SEO optimizations across all educational pages to improve search engine visibility and LLM recommendations.",
        "details": "For each educational page, implement:\n\n1. Meta Tags:\n   - Unique, keyword-rich title tags (50-60 characters)\n   - Meta descriptions (150-160 characters) targeting specific queries\n   - Canonical URLs to prevent duplicate content issues\n   - Meta robots tags set appropriately\n\n2. Structured Data (JSON-LD format):\n   - FAQ Schema for question sections\n   - HowTo Schema for step-by-step guides\n   - Tool Schema for calculator references\n   - BreadcrumbList Schema for navigation context\n\n3. Open Graph & Twitter Cards:\n   - og:title, og:description, og:image, og:url\n   - twitter:card, twitter:title, twitter:description, twitter:image\n\n4. Performance Optimizations:\n   - Implement resource hints (preconnect, preload)\n   - Set up responsive images with srcset and sizes\n   - Configure proper caching headers\n   - Optimize critical rendering path\n\nImplementation example for JSON-LD FAQ Schema:\n```javascript\n<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"FAQPage\",\n  \"mainEntity\": [{\n    \"@type\": \"Question\",\n    \"name\": \"Should I pay off debt or invest?\",\n    \"acceptedAnswer\": {\n      \"@type\": \"Answer\",\n      \"text\": \"The answer depends on interest rates...\"\n    }\n  }]\n}\n</script>\n```\n\nUse schema.org's latest specifications and Google's structured data testing tool to validate all implementations.",
        "testStrategy": "1. Validate structured data using Google's Rich Results Test\n2. Test meta tags with SEO analysis tools (Screaming Frog, SEMrush)\n3. Verify Open Graph tags using Facebook's Sharing Debugger\n4. Test Twitter Cards using Twitter Card Validator\n5. Run Lighthouse SEO audits and aim for 100/100 score\n6. Test page load speed using PageSpeed Insights and aim for <2s FCP\n7. Validate schema markup using Schema.org Validator",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Develop LLM-Friendly Content Structure",
        "description": "Create comprehensive, structured content for educational pages that is optimized for LLM recommendations and answers common user queries about debt vs. investment decisions.",
        "details": "For each educational page, develop content following these guidelines:\n\n1. Clear Methodology Explanations:\n   - Define all financial terms used in calculations\n   - Explain the mathematical formulas with examples\n   - Provide step-by-step decision frameworks\n\n2. Example Scenarios with Specific Numbers:\n   - Create 3-5 detailed scenarios per page (e.g., $10,000 credit card debt at 18% vs. investing in index fund with 7% return)\n   - Include tables comparing outcomes over different time periods\n   - Show calculations with actual numbers\n\n3. Edge Case Coverage:\n   - Address variable interest rates\n   - Consider tax implications\n   - Discuss emergency fund considerations\n   - Cover risk tolerance factors\n\n4. FAQ Sections:\n   - Structure as direct questions with concise answers\n   - Include common variations of similar questions\n   - Use natural language that matches search queries\n\n5. Internal Linking Strategy:\n   - Link between educational pages with descriptive anchor text\n   - Link to calculator with clear calls-to-action\n   - Use breadcrumb navigation\n\nContent should follow the inverted pyramid structure (most important information first) and use clear subheadings that directly answer user questions.\n\nImplement content in HTML with proper semantic markup, using:\n- <section> for major content divisions\n- <h2>, <h3> for clear hierarchy\n- <table> for comparison data\n- <dl>, <dt>, <dd> for term definitions",
        "testStrategy": "1. Conduct user testing to verify content clarity and comprehensiveness\n2. Use readability tools to ensure content is at appropriate reading level (aim for 8th-10th grade)\n3. Test content with actual LLM queries to verify it provides expected answers\n4. Verify all financial calculations for accuracy\n5. Check for keyword density and natural language using SEO tools\n6. Validate that all scenarios and examples use realistic numbers\n7. Ensure all technical terms are properly defined",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Build Advanced Mode Toggle Component",
        "description": "Create a toggle switch component that allows users to express interest in advanced features while clearly communicating that these features are still in development.",
        "details": "Implement a toggle switch component with the following specifications:\n\n1. UI Implementation:\n   - Use native HTML elements for accessibility (input type=\"checkbox\")\n   - Style with CSS to match existing design system\n   - Include \"Advanced Mode\" label with appropriate contrast\n   - Add subtle animation for toggle interaction\n   - Position in a non-disruptive location in the UI\n\n2. Behavior:\n   - Toggle should be clickable/tappable\n   - When activated, it should trigger the modal popup\n   - After modal interaction, toggle should return to off position\n   - Should not persist in \"on\" state between sessions\n\n3. Accessibility:\n   - Ensure keyboard navigability (tab focus, space/enter activation)\n   - Add appropriate ARIA attributes (aria-checked, aria-label)\n   - Maintain color contrast ratio of at least 4.5:1\n   - Include focus indicators\n\nExample implementation:\n```jsx\nconst AdvancedModeToggle = () => {\n  const [isChecked, setIsChecked] = useState(false);\n  \n  const handleToggle = () => {\n    setIsChecked(true);\n    // Show modal\n    showAdvancedFeaturesModal();\n    // Reset toggle after modal interaction\n    setTimeout(() => setIsChecked(false), 100);\n  };\n  \n  return (\n    <div className=\"advanced-mode-container\">\n      <label htmlFor=\"advanced-mode\" className=\"toggle-label\">\n        Advanced Mode\n      </label>\n      <div className=\"toggle-switch\">\n        <input\n          type=\"checkbox\"\n          id=\"advanced-mode\"\n          checked={isChecked}\n          onChange={handleToggle}\n          aria-label=\"Toggle advanced mode\"\n        />\n        <span className=\"toggle-slider\"></span>\n      </div>\n    </div>\n  );\n};\n```\n\nCSS should use variables from existing design system for consistency.",
        "testStrategy": "1. Test toggle functionality across browsers (Chrome, Firefox, Safari, Edge)\n2. Verify keyboard accessibility (tab navigation, space/enter activation)\n3. Test screen reader compatibility with NVDA, JAWS, and VoiceOver\n4. Verify toggle resets to off position after modal interaction\n5. Test on touch devices for appropriate tap target size\n6. Validate color contrast using accessibility tools\n7. Verify the component doesn't break existing UI layout",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Create Advanced Features Modal Component",
        "description": "Develop a modal popup that displays when the Advanced Mode toggle is activated, showing potential advanced features and collecting user interest data.",
        "details": "Implement a modal component with the following specifications:\n\n1. Modal Structure:\n   - Clear header: \"Advanced Mode Features\"\n   - Explanatory text: \"Advanced mode is still in development!\"\n   - List of potential advanced features (as specified in PRD)\n   - \"I'm interested - let us know!\" primary button\n   - Optional text input for specific feature requests\n   - Close button (X in corner and/or \"Maybe Later\" button)\n\n2. Feature List Display:\n   - Format as checkboxes or selectable items\n   - Allow multiple selection\n   - Include brief description for each feature\n   - Group related features if possible\n\n3. Technical Implementation:\n   - Use React Portal or equivalent for proper DOM placement\n   - Implement focus trapping within modal\n   - Add ESC key listener for closing\n   - Include click-outside-to-close functionality\n   - Animate entrance/exit with CSS transitions\n\n4. Accessibility:\n   - Set aria-modal=\"true\"\n   - Use proper heading hierarchy\n   - Ensure all interactive elements are keyboard accessible\n   - Return focus to toggle after closing\n\nExample implementation:\n```jsx\nconst AdvancedFeaturesModal = ({ isOpen, onClose, onSubmit }) => {\n  const [selectedFeatures, setSelectedFeatures] = useState([]);\n  const [customRequest, setCustomRequest] = useState('');\n  \n  const handleFeatureToggle = (feature) => {\n    setSelectedFeatures(prev => \n      prev.includes(feature)\n        ? prev.filter(f => f !== feature)\n        : [...prev, feature]\n    );\n  };\n  \n  const handleSubmit = () => {\n    onSubmit({ selectedFeatures, customRequest });\n    onClose();\n  };\n  \n  if (!isOpen) return null;\n  \n  return (\n    <FocusTrap>\n      <div className=\"modal-overlay\" onClick={onClose}>\n        <div className=\"modal-content\" onClick={e => e.stopPropagation()}>\n          <button className=\"close-button\" onClick={onClose} aria-label=\"Close modal\">×</button>\n          <h2>Advanced Mode Features</h2>\n          <p>Advanced mode is still in development!</p>\n          \n          <div className=\"feature-list\">\n            {advancedFeatures.map(feature => (\n              <label key={feature.id} className=\"feature-item\">\n                <input\n                  type=\"checkbox\"\n                  checked={selectedFeatures.includes(feature.id)}\n                  onChange={() => handleFeatureToggle(feature.id)}\n                />\n                <span>{feature.name}</span>\n                <p>{feature.description}</p>\n              </label>\n            ))}\n          </div>\n          \n          <textarea\n            placeholder=\"Request specific features...\"\n            value={customRequest}\n            onChange={e => setCustomRequest(e.target.value)}\n          />\n          \n          <div className=\"modal-actions\">\n            <button className=\"primary-button\" onClick={handleSubmit}>\n              I'm interested - let us know!\n            </button>\n            <button className=\"secondary-button\" onClick={onClose}>\n              Maybe Later\n            </button>\n          </div>\n        </div>\n      </div>\n    </FocusTrap>\n  );\n};\n```",
        "testStrategy": "1. Test modal opening and closing functionality\n2. Verify focus trapping works correctly\n3. Test keyboard navigation within modal\n4. Verify screen reader accessibility\n5. Test feature selection and submission\n6. Verify custom request input works correctly\n7. Test on different screen sizes for responsive behavior\n8. Verify ESC key and click-outside closing functionality\n9. Test that focus returns to toggle after closing",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement GitHub Issues Integration for Advanced Mode",
        "description": "Create a system to automatically generate GitHub issues when users express interest in advanced features through the modal.",
        "details": "Implement GitHub Issues API integration with the following specifications:\n\n1. API Integration:\n   - Use GitHub REST API v3 for issue creation\n   - Endpoint: `POST /repos/{owner}/{repo}/issues`\n   - Authentication: Use GITHUB_TOKEN from environment variables\n   - Handle rate limiting and error cases gracefully\n\n2. Issue Creation Logic:\n   - Title format: \"Advanced Mode Interest - [timestamp]\"\n   - Labels: [\"feedback\", \"advanced-mode\"]\n   - Body template should include:\n     * List of features user is interested in\n     * Custom feature request text (if provided)\n     * Basic context (timestamp, referrer URL, no PII)\n\n3. Security Considerations:\n   - Use environment variables for GitHub token\n   - Implement proper CORS handling\n   - Sanitize all user inputs before submission\n   - Use fine-grained token with minimal permissions\n\n4. Error Handling:\n   - Implement retry logic for network failures\n   - Show success/error feedback to users\n   - Log errors (but don't expose sensitive details to users)\n   - Graceful degradation if GitHub API is unavailable\n\nExample implementation:\n```javascript\nasync function createGitHubIssue(selectedFeatures, customRequest) {\n  const timestamp = new Date().toISOString();\n  const featuresList = selectedFeatures.map(id => \n    `- ${advancedFeatures.find(f => f.id === id).name}`\n  ).join('\\n');\n  \n  const body = `## Advanced Mode Interest\\n\\n` +\n    `**Timestamp:** ${timestamp}\\n\\n` +\n    `**Interested Features:**\\n${featuresList}\\n\\n` +\n    (customRequest ? `**Custom Request:**\\n${customRequest}\\n\\n` : '') +\n    `**Context:**\\n- Referrer: ${document.referrer || 'Direct'}\\n` +\n    `- User Agent: ${navigator.userAgent}\\n`;\n  \n  try {\n    const response = await fetch('https://api.github.com/repos/owner/repo/issues', {\n      method: 'POST',\n      headers: {\n        'Authorization': `token ${process.env.GITHUB_TOKEN}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        title: `Advanced Mode Interest - ${new Date().toLocaleString()}`,\n        body,\n        labels: ['feedback', 'advanced-mode']\n      })\n    });\n    \n    if (!response.ok) {\n      throw new Error(`GitHub API error: ${response.status}`);\n    }\n    \n    return { success: true };\n  } catch (error) {\n    console.error('Failed to create GitHub issue:', error);\n    return { \n      success: false, \n      error: 'Failed to submit feedback. Please try again later.'\n    };\n  }\n}\n```",
        "testStrategy": "1. Create test GitHub repository for integration testing\n2. Test issue creation with various feature selections\n3. Verify correct formatting of issue title, body, and labels\n4. Test error handling by intentionally using invalid tokens\n5. Verify rate limit handling\n6. Test with network throttling to ensure proper timeout handling\n7. Verify no sensitive information is included in issues\n8. Test with mock API responses for consistent unit testing",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Create Feedback Button Component",
        "description": "Implement an unobtrusive floating feedback button that allows users to report bugs or share feedback from anywhere in the application.",
        "details": "Develop a feedback button component with the following specifications:\n\n1. UI Implementation:\n   - Create a small, floating button fixed to bottom-right corner\n   - Use appropriate icon (speech bubble, feedback, etc.)\n   - Include subtle hover effects\n   - Ensure sufficient contrast against all backgrounds\n   - Make responsive for all device sizes\n\n2. Positioning and Behavior:\n   - Fixed position that doesn't interfere with main content\n   - Z-index high enough to appear above other elements\n   - Small on mobile, slightly larger on desktop\n   - Optional: Subtle entrance animation on page load\n\n3. Accessibility:\n   - Ensure keyboard accessibility (tab focus)\n   - Add appropriate ARIA attributes\n   - Include descriptive text (\"Feedback\" or similar)\n   - Maintain proper contrast ratio\n\n4. Technical Implementation:\n   - Use CSS for positioning and styling\n   - Implement click handler to open feedback modal\n   - Consider using IntersectionObserver to hide when certain elements are in view\n\nExample implementation:\n```jsx\nconst FeedbackButton = ({ onClick }) => {\n  return (\n    <button \n      className=\"feedback-button\"\n      onClick={onClick}\n      aria-label=\"Provide feedback\"\n    >\n      <svg className=\"feedback-icon\" viewBox=\"0 0 24 24\">\n        {/* SVG path for feedback icon */}\n      </svg>\n      <span className=\"feedback-text\">Feedback</span>\n    </button>\n  );\n};\n\n// CSS\n.feedback-button {\n  position: fixed;\n  bottom: 20px;\n  right: 20px;\n  display: flex;\n  align-items: center;\n  padding: 8px 16px;\n  background-color: var(--primary-color);\n  color: white;\n  border: none;\n  border-radius: 20px;\n  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);\n  cursor: pointer;\n  z-index: 1000;\n  transition: transform 0.2s ease;\n}\n\n.feedback-button:hover {\n  transform: translateY(-2px);\n}\n\n.feedback-icon {\n  width: 16px;\n  height: 16px;\n  margin-right: 8px;\n}\n\n@media (max-width: 768px) {\n  .feedback-button {\n    padding: 8px;\n  }\n  \n  .feedback-text {\n    display: none;\n  }\n  \n  .feedback-icon {\n    margin-right: 0;\n  }\n}\n```",
        "testStrategy": "1. Test button visibility across different page backgrounds\n2. Verify button positioning on various screen sizes\n3. Test keyboard accessibility\n4. Verify click handler correctly opens feedback modal\n5. Test with screen readers to ensure proper accessibility\n6. Verify button doesn't interfere with important page content\n7. Test z-index to ensure button appears above other elements\n8. Verify hover and focus states work correctly",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Develop Feedback Modal Component",
        "description": "Create a modal component that allows users to submit bug reports or general feedback, with options to categorize their submission.",
        "details": "Implement a feedback modal with the following specifications:\n\n1. Modal Structure:\n   - Clear header: \"Share Your Feedback\"\n   - Two option buttons: \"Report a Bug\" and \"Share Feedback\"\n   - Form with description textarea\n   - Submit button\n   - Cancel/close button\n\n2. Form Behavior:\n   - Different placeholder text based on selected option\n   - Optional: Bug report form could include additional fields (steps to reproduce, etc.)\n   - Textarea with character counter (optional)\n   - Form validation for required fields\n\n3. Technical Implementation:\n   - Use React Portal or equivalent for proper DOM placement\n   - Implement focus trapping within modal\n   - Add ESC key listener for closing\n   - Include click-outside-to-close functionality\n   - Animate entrance/exit with CSS transitions\n\n4. Accessibility:\n   - Set aria-modal=\"true\"\n   - Use proper heading hierarchy\n   - Ensure all interactive elements are keyboard accessible\n   - Return focus to feedback button after closing\n\nExample implementation:\n```jsx\nconst FeedbackModal = ({ isOpen, onClose, onSubmit }) => {\n  const [feedbackType, setFeedbackType] = useState(null); // 'bug' or 'feedback'\n  const [description, setDescription] = useState('');\n  \n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (!description.trim()) return;\n    \n    onSubmit({\n      type: feedbackType,\n      description\n    });\n    \n    // Reset form\n    setFeedbackType(null);\n    setDescription('');\n    onClose();\n  };\n  \n  if (!isOpen) return null;\n  \n  return (\n    <FocusTrap>\n      <div className=\"modal-overlay\" onClick={onClose}>\n        <div className=\"modal-content\" onClick={e => e.stopPropagation()}>\n          <button className=\"close-button\" onClick={onClose} aria-label=\"Close modal\">×</button>\n          <h2>Share Your Feedback</h2>\n          \n          {!feedbackType ? (\n            <div className=\"feedback-type-selection\">\n              <button \n                className=\"type-button bug\"\n                onClick={() => setFeedbackType('bug')}\n              >\n                Report a Bug\n              </button>\n              <button \n                className=\"type-button feedback\"\n                onClick={() => setFeedbackType('feedback')}\n              >\n                Share Feedback\n              </button>\n            </div>\n          ) : (\n            <form onSubmit={handleSubmit}>\n              <h3>{feedbackType === 'bug' ? 'Report a Bug' : 'Share Your Thoughts'}</h3>\n              \n              <textarea\n                placeholder={feedbackType === 'bug' \n                  ? 'Please describe the issue you encountered...'\n                  : 'We value your feedback! Tell us what you think...'}\n                value={description}\n                onChange={e => setDescription(e.target.value)}\n                required\n                rows={5}\n              />\n              \n              <div className=\"modal-actions\">\n                <button type=\"submit\" className=\"primary-button\">\n                  Submit\n                </button>\n                <button \n                  type=\"button\" \n                  className=\"secondary-button\" \n                  onClick={() => setFeedbackType(null)}\n                >\n                  Back\n                </button>\n              </div>\n            </form>\n          )}\n        </div>\n      </div>\n    </FocusTrap>\n  );\n};\n```",
        "testStrategy": "1. Test modal opening and closing functionality\n2. Verify focus trapping works correctly\n3. Test keyboard navigation within modal\n4. Verify screen reader accessibility\n5. Test form submission with different feedback types\n6. Verify form validation works correctly\n7. Test on different screen sizes for responsive behavior\n8. Verify ESC key and click-outside closing functionality\n9. Test that focus returns to feedback button after closing",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement GitHub Issues Integration for Feedback System",
        "description": "Create a system to automatically generate GitHub issues when users submit bug reports or feedback through the feedback modal.",
        "details": "Implement GitHub Issues API integration with the following specifications:\n\n1. API Integration:\n   - Use GitHub REST API v3 for issue creation\n   - Endpoint: `POST /repos/{owner}/{repo}/issues`\n   - Authentication: Use GITHUB_TOKEN from environment variables\n   - Handle rate limiting and error cases gracefully\n\n2. Issue Creation Logic:\n   - For bugs:\n     * Title format: \"Bug Report - [timestamp]\"\n     * Labels: [\"bug\"]\n   - For feedback:\n     * Title format: \"User Feedback - [timestamp]\"\n     * Labels: [\"feedback\"]\n   - Body template should include:\n     * User description\n     * Basic context (URL, user agent, timestamp)\n     * No personally identifiable information\n\n3. Security Considerations:\n   - Use environment variables for GitHub token\n   - Implement proper CORS handling\n   - Sanitize all user inputs before submission\n   - Use fine-grained token with minimal permissions\n\n4. Error Handling:\n   - Implement retry logic for network failures\n   - Show success/error feedback to users\n   - Log errors (but don't expose sensitive details to users)\n   - Graceful degradation if GitHub API is unavailable\n\nExample implementation:\n```javascript\nasync function createGitHubIssue(feedbackData) {\n  const { type, description } = feedbackData;\n  const timestamp = new Date().toISOString();\n  const isBug = type === 'bug';\n  \n  const title = isBug \n    ? `Bug Report - ${new Date().toLocaleString()}`\n    : `User Feedback - ${new Date().toLocaleString()}`;\n    \n  const body = `## ${isBug ? 'Bug Report' : 'User Feedback'}\\n\\n` +\n    `**Description:**\\n${description}\\n\\n` +\n    `**Context:**\\n` +\n    `- URL: ${window.location.href}\\n` +\n    `- Timestamp: ${timestamp}\\n` +\n    `- User Agent: ${navigator.userAgent}\\n`;\n  \n  try {\n    const response = await fetch('https://api.github.com/repos/owner/repo/issues', {\n      method: 'POST',\n      headers: {\n        'Authorization': `token ${process.env.GITHUB_TOKEN}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        title,\n        body,\n        labels: [isBug ? 'bug' : 'feedback']\n      })\n    });\n    \n    if (!response.ok) {\n      throw new Error(`GitHub API error: ${response.status}`);\n    }\n    \n    return { success: true };\n  } catch (error) {\n    console.error('Failed to create GitHub issue:', error);\n    return { \n      success: false, \n      error: 'Failed to submit feedback. Please try again later.'\n    };\n  }\n}\n```\n\nCreate a reusable service that can be used by both the Advanced Mode feature and the Feedback System:",
        "testStrategy": "1. Create test GitHub repository for integration testing\n2. Test issue creation for both bug reports and feedback\n3. Verify correct formatting of issue title, body, and labels\n4. Test error handling by intentionally using invalid tokens\n5. Verify rate limit handling\n6. Test with network throttling to ensure proper timeout handling\n7. Verify no sensitive information is included in issues\n8. Test with mock API responses for consistent unit testing",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Integrate Components with Existing Application",
        "description": "Integrate all new components (Advanced Mode Toggle, Feedback Button, and associated modals) with the existing application while ensuring zero breaking changes.",
        "details": "Integrate new components with the following approach:\n\n1. Component Placement:\n   - Advanced Mode Toggle: Place near calculator controls, visually distinct but integrated\n   - Feedback Button: Fixed position in bottom-right corner\n   - Ensure components don't interfere with existing UI elements\n\n2. State Management Integration:\n   - Use existing state management system if available (Redux, Context API, etc.)\n   - If no state management exists, implement minimal context for new features\n   - Ensure new state doesn't conflict with existing application state\n\n3. Styling Integration:\n   - Match existing design system (colors, typography, spacing)\n   - Use existing CSS variables/tokens\n   - Implement BEM or similar methodology for CSS class naming\n   - Use CSS modules or styled-components to avoid style conflicts\n\n4. Environment Variables:\n   - Add GITHUB_TOKEN to .env file\n   - Update build process to include new environment variables\n   - Document required environment variables\n\n5. Error Boundary Implementation:\n   - Wrap new components in error boundaries\n   - Ensure failures in new components don't crash the entire application\n   - Implement graceful fallbacks\n\nExample integration approach:\n```jsx\n// In main App or relevant container component\nimport { useState } from 'react';\nimport AdvancedModeToggle from './components/AdvancedModeToggle';\nimport AdvancedFeaturesModal from './components/AdvancedFeaturesModal';\nimport FeedbackButton from './components/FeedbackButton';\nimport FeedbackModal from './components/FeedbackModal';\nimport { createGitHubIssue } from './services/githubService';\n\nfunction App() {\n  // Existing app code...\n  \n  // New state for modals\n  const [isAdvancedModalOpen, setIsAdvancedModalOpen] = useState(false);\n  const [isFeedbackModalOpen, setIsFeedbackModalOpen] = useState(false);\n  \n  // Handlers for new components\n  const handleAdvancedToggle = () => {\n    setIsAdvancedModalOpen(true);\n  };\n  \n  const handleAdvancedSubmit = async (data) => {\n    const result = await createGitHubIssue({\n      type: 'advanced-mode',\n      ...data\n    });\n    \n    // Show success/error notification\n    // ...\n  };\n  \n  const handleFeedbackClick = () => {\n    setIsFeedbackModalOpen(true);\n  };\n  \n  const handleFeedbackSubmit = async (data) => {\n    const result = await createGitHubIssue(data);\n    \n    // Show success/error notification\n    // ...\n  };\n  \n  return (\n    <ErrorBoundary fallback={<div>Something went wrong</div>}>\n      <div className=\"app\">\n        {/* Existing app content */}\n        \n        {/* New components */}\n        <div className=\"calculator-controls\">\n          {/* Existing controls */}\n          <AdvancedModeToggle onToggle={handleAdvancedToggle} />\n        </div>\n        \n        <FeedbackButton onClick={handleFeedbackClick} />\n        \n        <AdvancedFeaturesModal\n          isOpen={isAdvancedModalOpen}\n          onClose={() => setIsAdvancedModalOpen(false)}\n          onSubmit={handleAdvancedSubmit}\n        />\n        \n        <FeedbackModal\n          isOpen={isFeedbackModalOpen}\n          onClose={() => setIsFeedbackModalOpen(false)}\n          onSubmit={handleFeedbackSubmit}\n        />\n      </div>\n    </ErrorBoundary>\n  );\n}\n```",
        "testStrategy": "1. Verify all existing functionality continues to work\n2. Test integration on all supported browsers\n3. Verify responsive behavior across device sizes\n4. Test with JavaScript disabled to ensure graceful degradation\n5. Verify no console errors are introduced\n6. Test performance impact of new components\n7. Verify environment variables are properly accessed\n8. Test error boundaries by intentionally causing errors",
        "priority": "high",
        "dependencies": [
          4,
          5,
          6,
          7,
          8,
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implement Cross-Browser and Accessibility Testing",
        "description": "Conduct comprehensive cross-browser testing and accessibility audits to ensure all new features work correctly across different environments and are accessible to all users.",
        "details": "Implement testing with the following approach:\n\n1. Cross-Browser Testing:\n   - Test on latest versions of Chrome, Firefox, Safari, and Edge\n   - Test on iOS Safari and Android Chrome\n   - Verify visual consistency across browsers\n   - Test JavaScript functionality across browsers\n   - Verify CSS compatibility issues\n\n2. Accessibility Testing:\n   - Conduct automated testing with axe-core or similar\n   - Test with screen readers (NVDA, JAWS, VoiceOver)\n   - Verify keyboard navigation throughout the application\n   - Check color contrast ratios\n   - Verify proper ARIA attributes\n   - Test focus management in modals\n\n3. Responsive Testing:\n   - Test on multiple device sizes (320px to 1920px+)\n   - Verify breakpoints work correctly\n   - Test touch interactions on mobile devices\n   - Verify text readability at all sizes\n\n4. Performance Testing:\n   - Measure impact of new components on page load time\n   - Test with throttled network conditions\n   - Verify memory usage\n   - Check for layout shifts\n\nImplementation approach:\n```javascript\n// Example automated accessibility test with axe-core\nimport { axe } from 'jest-axe';\n\ndescribe('Accessibility tests', () => {\n  it('Advanced Mode Toggle should not have accessibility violations', async () => {\n    const { container } = render(<AdvancedModeToggle />);\n    const results = await axe(container);\n    expect(results).toHaveNoViolations();\n  });\n  \n  it('Feedback Modal should not have accessibility violations', async () => {\n    const { container } = render(\n      <FeedbackModal isOpen={true} onClose={() => {}} onSubmit={() => {}} />\n    );\n    const results = await axe(container);\n    expect(results).toHaveNoViolations();\n  });\n});\n```\n\nCreate a comprehensive testing checklist document for manual testing across browsers and devices.",
        "testStrategy": "1. Create automated accessibility tests using axe-core or similar\n2. Set up cross-browser testing using BrowserStack or similar service\n3. Create a test matrix covering all browser/device combinations\n4. Develop specific test cases for keyboard navigation\n5. Test with actual assistive technologies\n6. Verify WCAG 2.1 AA compliance\n7. Document and prioritize any issues found\n8. Verify fixes don't introduce new issues",
        "priority": "high",
        "dependencies": [
          10
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Analytics and Success Metrics Tracking",
        "description": "Set up analytics tracking to measure the success of the new features, focusing on SEO performance, user engagement with advanced features, and feedback system usage.",
        "details": "Implement analytics tracking with the following approach:\n\n1. SEO Performance Tracking:\n   - Set up Google Search Console for keyword tracking\n   - Implement structured data monitoring\n   - Track organic traffic to educational pages\n   - Monitor LLM referrals through UTM parameters\n   - Set up alerts for significant ranking changes\n\n2. User Engagement Tracking:\n   - Track Advanced Mode toggle interactions\n   - Measure which advanced features generate most interest\n   - Monitor feedback submission rates\n   - Track user paths through educational content\n\n3. Technical Implementation:\n   - Use existing analytics solution if available (Google Analytics, Plausible, etc.)\n   - If no analytics exists, implement minimal tracking\n   - Create custom events for specific interactions\n   - Set up conversion goals\n\n4. Dashboard Creation:\n   - Create a simple dashboard for key metrics\n   - Set up regular reporting\n   - Define success thresholds\n\nExample implementation for tracking events:\n```javascript\n// Analytics service\nconst trackEvent = (category, action, label = null, value = null) => {\n  // If using Google Analytics\n  if (window.gtag) {\n    window.gtag('event', action, {\n      event_category: category,\n      event_label: label,\n      value: value\n    });\n  }\n  \n  // If using custom analytics\n  console.log(`[Analytics] ${category} - ${action} - ${label} - ${value}`);\n};\n\n// Usage in components\nconst handleAdvancedToggle = () => {\n  trackEvent('Engagement', 'advanced_mode_toggle');\n  setIsAdvancedModalOpen(true);\n};\n\nconst handleAdvancedSubmit = async (data) => {\n  trackEvent('Engagement', 'advanced_features_interest', data.selectedFeatures.join(','));\n  // Rest of submission logic\n};\n\nconst handleFeedbackSubmit = async (data) => {\n  trackEvent('Feedback', data.type === 'bug' ? 'bug_report' : 'feedback_submission');\n  // Rest of submission logic\n};\n```\n\nCreate a metrics dashboard that tracks:\n1. Organic traffic to educational pages\n2. Referral traffic from LLMs\n3. Advanced mode interest by feature\n4. Feedback submission rates\n5. Bug report vs. general feedback ratio",
        "testStrategy": "1. Verify analytics events are firing correctly\n2. Test with analytics debugging tools\n3. Validate data is appearing in analytics dashboard\n4. Test UTM parameter tracking\n5. Verify custom events are properly categorized\n6. Test conversion goal tracking\n7. Verify Search Console integration\n8. Create test scenarios for each key metric",
        "priority": "medium",
        "dependencies": [
          2,
          3,
          10
        ],
        "status": "done",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-03T16:24:42.929Z",
      "updated": "2025-08-03T17:03:29.275Z",
      "description": "Tasks for master context"
    }
  }
}