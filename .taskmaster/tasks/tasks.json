{
  "master": {
    "tasks": [
      {
        "id": 16,
        "title": "Setup Project Structure and Dependencies",
        "description": "Initialize the project repository with a modern frontend framework and set up the necessary dependencies for a single page application with chart capabilities.",
        "details": "Create a new project using React 18 with TypeScript for type safety. Use Vite as the build tool for faster development experience. Install essential dependencies:\n- React 18.2.0+\n- TypeScript 5.0.0+\n- Vite 4.4.0+\n- Chart.js 4.3.0+ with react-chartjs-2 for visualizations\n- TanStack Query (React Query) v4 for potential data fetching\n- Zod 3.21.0+ for input validation\n- Tailwind CSS 3.3.0+ for styling\n- Vitest and React Testing Library for testing\n\nCreate the basic folder structure:\n```\nsrc/\n  assets/\n  components/\n  hooks/\n  utils/\n  types/\n  App.tsx\n  main.tsx\n```\n\nSetup ESLint and Prettier for code quality and formatting. Configure Tailwind CSS for the project.",
        "testStrategy": "Verify that the project builds successfully without errors. Run a smoke test to ensure the application renders a basic component. Check that all dependencies are correctly installed and configured. Validate the TypeScript configuration works as expected.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Create Core Layout Components",
        "description": "Develop the main layout components for the single page application with three distinct sections for debt information, investment information, and cash flow information.",
        "details": "Create the following components:\n\n1. `AppContainer.tsx`: Main container component that holds all three sections\n2. `DebtSection.tsx`: Section for debt information inputs\n3. `InvestmentSection.tsx`: Section for investment information inputs\n4. `CashFlowSection.tsx`: Section for cash flow information inputs\n5. `ResultsSection.tsx`: Section to display the chart and recommendation\n\nImplement a responsive grid layout using Tailwind CSS grid or flexbox:\n```tsx\n// AppContainer.tsx example structure\nconst AppContainer = () => {\n  return (\n    <div className=\"container mx-auto px-4 py-8\">\n      <h1 className=\"text-3xl font-bold mb-8\">Invest vs Debt Calculator</h1>\n      <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6\">\n        <DebtSection />\n        <InvestmentSection />\n        <CashFlowSection />\n      </div>\n      <ResultsSection />\n    </div>\n  );\n};\n```\n\nEnsure the layout is responsive and follows the visual hierarchy specified in the PRD, with clear section separation and the chart as the focal point.",
        "testStrategy": "Test the layout on different screen sizes to ensure responsiveness. Verify that all three sections are visible simultaneously on desktop. Check that the layout adapts appropriately on mobile devices. Validate that the sections have clear visual boundaries and follow the specified visual hierarchy.",
        "priority": "high",
        "dependencies": [
          16
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Implement Form Input Components",
        "description": "Create reusable form input components for the various input types needed across the calculator sections, including dollar inputs, percentage inputs, and dropdown selectors.",
        "details": "Develop the following reusable form components with built-in validation:\n\n1. `CurrencyInput.tsx`: For dollar amount inputs with proper formatting\n2. `PercentageInput.tsx`: For interest rate and return rate inputs\n3. `DropdownSelect.tsx`: For frequency selection\n4. `NumberInput.tsx`: For time remaining inputs\n\nUse React Hook Form (v7.43.0+) for form state management and Zod for validation schemas.\n\nExample implementation for CurrencyInput:\n```tsx\ninterface CurrencyInputProps {\n  label: string;\n  value: number;\n  onChange: (value: number) => void;\n  error?: string;\n  placeholder?: string;\n}\n\nconst CurrencyInput = ({ label, value, onChange, error, placeholder }: CurrencyInputProps) => {\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const rawValue = e.target.value.replace(/[^0-9.]/g, '');\n    const numValue = parseFloat(rawValue);\n    onChange(isNaN(numValue) ? 0 : numValue);\n  };\n\n  return (\n    <div className=\"mb-4\">\n      <label className=\"block text-sm font-medium mb-1\">{label}</label>\n      <div className=\"relative\">\n        <span className=\"absolute left-3 top-1/2 transform -translate-y-1/2\">$</span>\n        <input\n          type=\"text\"\n          className={`pl-6 w-full p-2 border rounded ${error ? 'border-red-500' : 'border-gray-300'}`}\n          value={value === 0 ? '' : value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}\n          onChange={handleChange}\n          placeholder={placeholder}\n        />\n      </div>\n      {error && <p className=\"text-red-500 text-xs mt-1\">{error}</p>}\n    </div>\n  );\n};\n```\n\nImplement similar components for percentage inputs and dropdown selects with appropriate formatting and validation.",
        "testStrategy": "Unit test each input component to verify correct rendering and behavior. Test input validation for edge cases (negative values, extremely large values, invalid characters). Verify that currency formatting works correctly. Test that onChange handlers are called with the correct values. Ensure accessibility by testing keyboard navigation and screen reader compatibility.",
        "priority": "high",
        "dependencies": [
          16,
          17
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Implement Debt Information Section",
        "description": "Create the debt information section with all required input fields: current debt amount, interest rate, minimum payment frequency, minimum payment amount, and time remaining.",
        "details": "Implement the DebtSection component with the following fields:\n\n1. Current Debt Amount (dollar input)\n2. Current Interest Rate (percentage input)\n3. Minimum Payment Frequency (dropdown with options: weekly, bi-weekly, monthly, quarterly, annually)\n4. Minimum Payment Amount (dollar input)\n5. Time Remaining on Debt (number input with default of 30 years)\n\nUse the reusable form components created earlier. Implement local state management using React's useState or useReducer hooks.\n\n```tsx\nconst DebtSection = () => {\n  const [debtInfo, setDebtInfo] = useState({\n    amount: 0,\n    interestRate: 0,\n    paymentFrequency: 'monthly',\n    paymentAmount: 0,\n    timeRemaining: 30\n  });\n\n  const handleChange = (field: string, value: any) => {\n    setDebtInfo(prev => ({ ...prev, [field]: value }));\n  };\n\n  return (\n    <div className=\"bg-white p-6 rounded-lg shadow-md\">\n      <h2 className=\"text-xl font-semibold mb-4\">Debt Information</h2>\n      <CurrencyInput\n        label=\"Current Debt Amount\"\n        value={debtInfo.amount}\n        onChange={(value) => handleChange('amount', value)}\n        placeholder=\"0.00\"\n      />\n      <PercentageInput\n        label=\"Current Interest Rate\"\n        value={debtInfo.interestRate}\n        onChange={(value) => handleChange('interestRate', value)}\n        placeholder=\"0.0\"\n      />\n      <DropdownSelect\n        label=\"Minimum Payment Frequency\"\n        value={debtInfo.paymentFrequency}\n        onChange={(value) => handleChange('paymentFrequency', value)}\n        options={[\n          { value: 'weekly', label: 'Weekly' },\n          { value: 'bi-weekly', label: 'Bi-weekly' },\n          { value: 'monthly', label: 'Monthly' },\n          { value: 'quarterly', label: 'Quarterly' },\n          { value: 'annually', label: 'Annually' }\n        ]}\n      />\n      <CurrencyInput\n        label=\"Minimum Payment Amount\"\n        value={debtInfo.paymentAmount}\n        onChange={(value) => handleChange('paymentAmount', value)}\n        placeholder=\"0.00\"\n      />\n      <NumberInput\n        label=\"Time Remaining on Debt (years)\"\n        value={debtInfo.timeRemaining}\n        onChange={(value) => handleChange('timeRemaining', value)}\n        min={1}\n        max={100}\n      />\n    </div>\n  );\n};\n```\n\nImplement real-time validation for each input field to ensure data integrity.",
        "testStrategy": "Unit test the DebtSection component to verify all inputs render correctly. Test that state updates properly when inputs change. Verify default values are set correctly. Test validation logic for each input field. Ensure the component integrates well with the parent container.",
        "priority": "medium",
        "dependencies": [
          18
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Implement Investment Information Section",
        "description": "Create the investment information section with input fields for current investment amount and expected rate of return.",
        "details": "Implement the InvestmentSection component with the following fields:\n\n1. Current Investment Amount (dollar input)\n2. Expected Rate of Return (percentage input)\n\nUse the reusable form components created earlier and implement local state management.\n\n```tsx\nconst InvestmentSection = () => {\n  const [investmentInfo, setInvestmentInfo] = useState({\n    amount: 0,\n    expectedReturn: 0\n  });\n\n  const handleChange = (field: string, value: any) => {\n    setInvestmentInfo(prev => ({ ...prev, [field]: value }));\n  };\n\n  return (\n    <div className=\"bg-white p-6 rounded-lg shadow-md\">\n      <h2 className=\"text-xl font-semibold mb-4\">Investment Information</h2>\n      <CurrencyInput\n        label=\"Current Investment Amount\"\n        value={investmentInfo.amount}\n        onChange={(value) => handleChange('amount', value)}\n        placeholder=\"0.00\"\n      />\n      <PercentageInput\n        label=\"Expected Rate of Return\"\n        value={investmentInfo.expectedReturn}\n        onChange={(value) => handleChange('expectedReturn', value)}\n        placeholder=\"0.0\"\n      />\n    </div>\n  );\n};\n```\n\nAdd tooltips or help text to explain concepts like \"Expected Rate of Return\" to users who may not be familiar with investment terminology.",
        "testStrategy": "Unit test the InvestmentSection component to verify all inputs render correctly. Test that state updates properly when inputs change. Verify validation logic for each input field. Test tooltips or help text functionality if implemented. Ensure the component integrates well with the parent container.",
        "priority": "medium",
        "dependencies": [
          18
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Implement Cash Flow Information Section",
        "description": "Create the cash flow information section with input fields for cash flow frequency and cash flow amount.",
        "details": "Implement the CashFlowSection component with the following fields:\n\n1. Cash Flow Frequency (dropdown with options: lump-sum, weekly, bi-weekly, monthly, quarterly, annually)\n2. Cash Flow Amount (dollar input)\n\nUse the reusable form components created earlier and implement local state management.\n\n```tsx\nconst CashFlowSection = () => {\n  const [cashFlowInfo, setCashFlowInfo] = useState({\n    frequency: 'monthly',\n    amount: 0\n  });\n\n  const handleChange = (field: string, value: any) => {\n    setCashFlowInfo(prev => ({ ...prev, [field]: value }));\n  };\n\n  return (\n    <div className=\"bg-white p-6 rounded-lg shadow-md\">\n      <h2 className=\"text-xl font-semibold mb-4\">Cash Flow Information</h2>\n      <DropdownSelect\n        label=\"Cash Flow Frequency\"\n        value={cashFlowInfo.frequency}\n        onChange={(value) => handleChange('frequency', value)}\n        options={[\n          { value: 'lump-sum', label: 'Lump-Sum' },\n          { value: 'weekly', label: 'Weekly' },\n          { value: 'bi-weekly', label: 'Bi-weekly' },\n          { value: 'monthly', label: 'Monthly' },\n          { value: 'quarterly', label: 'Quarterly' },\n          { value: 'annually', label: 'Annually' }\n        ]}\n      />\n      <CurrencyInput\n        label=\"Cash Flow Amount\"\n        value={cashFlowInfo.amount}\n        onChange={(value) => handleChange('amount', value)}\n        placeholder=\"0.00\"\n      />\n    </div>\n  );\n};\n```\n\nAdd explanatory text to clarify that this represents additional cash flow that could be allocated toward either debt payment or investment.",
        "testStrategy": "Unit test the CashFlowSection component to verify all inputs render correctly. Test that state updates properly when inputs change. Verify validation logic for each input field. Test that explanatory text is displayed correctly. Ensure the component integrates well with the parent container.",
        "priority": "medium",
        "dependencies": [
          18
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Create Global State Management",
        "description": "Implement a global state management solution to share data between components and enable real-time calculations as users input data.",
        "details": "Use React Context API with useReducer for global state management. Create the following files:\n\n1. `types/index.ts`: Define TypeScript interfaces for the application state\n2. `context/CalculatorContext.tsx`: Create the context and provider\n3. `context/calculatorReducer.ts`: Implement the reducer function\n\n```tsx\n// types/index.ts\nexport interface DebtInfo {\n  amount: number;\n  interestRate: number;\n  paymentFrequency: string;\n  paymentAmount: number;\n  timeRemaining: number;\n}\n\nexport interface InvestmentInfo {\n  amount: number;\n  expectedReturn: number;\n}\n\nexport interface CashFlowInfo {\n  frequency: string;\n  amount: number;\n}\n\nexport interface CalculatorState {\n  debtInfo: DebtInfo;\n  investmentInfo: InvestmentInfo;\n  cashFlowInfo: CashFlowInfo;\n  results: {\n    recommendation: string | null;\n    chartData: any | null;\n    crossoverPoint: number | null;\n    coveragePoint: number | null;\n  };\n}\n```\n\n```tsx\n// context/CalculatorContext.tsx\nimport React, { createContext, useContext, useReducer, ReactNode } from 'react';\nimport { calculatorReducer } from './calculatorReducer';\nimport { CalculatorState } from '../types';\n\nconst initialState: CalculatorState = {\n  debtInfo: {\n    amount: 0,\n    interestRate: 0,\n    paymentFrequency: 'monthly',\n    paymentAmount: 0,\n    timeRemaining: 30\n  },\n  investmentInfo: {\n    amount: 0,\n    expectedReturn: 0\n  },\n  cashFlowInfo: {\n    frequency: 'monthly',\n    amount: 0\n  },\n  results: {\n    recommendation: null,\n    chartData: null,\n    crossoverPoint: null,\n    coveragePoint: null\n  }\n};\n\nconst CalculatorContext = createContext<{\n  state: CalculatorState;\n  dispatch: React.Dispatch<any>;\n}>({ state: initialState, dispatch: () => null });\n\nexport const CalculatorProvider = ({ children }: { children: ReactNode }) => {\n  const [state, dispatch] = useReducer(calculatorReducer, initialState);\n\n  return (\n    <CalculatorContext.Provider value={{ state, dispatch }}>\n      {children}\n    </CalculatorContext.Provider>\n  );\n};\n\nexport const useCalculator = () => useContext(CalculatorContext);\n```\n\nUpdate the individual section components to use this global state instead of local state.",
        "testStrategy": "Test the context provider by rendering it with a test component and verifying that state is accessible. Test the reducer with various actions to ensure it updates state correctly. Verify that components can access and update the global state. Test that state persists correctly during the user session.",
        "priority": "high",
        "dependencies": [
          19,
          20,
          21
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Implement Financial Calculation Logic",
        "description": "Create utility functions to perform the financial calculations needed to determine whether paying off debt or investing is more optimal.",
        "details": "Create a `utils/calculations.ts` file with the following functions:\n\n1. `calculateDebtPayoff`: Calculate how debt will be paid off over time with minimum payments\n2. `calculateInvestmentGrowth`: Calculate how investments will grow over time\n3. `calculateCrossoverPoint`: Determine when investment balance would surpass debt balance\n4. `calculateCoveragePoint`: Determine when investment returns could cover debt payments\n5. `generateTimeSeriesData`: Generate time series data for the chart\n6. `determineOptimalStrategy`: Determine whether investing or paying off debt is more optimal\n\nUse financial formulas for compound interest and debt amortization:\n\n```typescript\n// Example implementation for debt payoff calculation\nexport const calculateDebtPayoff = (\n  principal: number,\n  annualInterestRate: number,\n  paymentAmount: number,\n  paymentFrequency: string,\n  additionalPayment: number = 0\n): { months: number; totalInterest: number; timeSeriesData: any[] } => {\n  // Convert annual interest rate to periodic rate based on payment frequency\n  const periodsPerYear = getPeriodsPerYear(paymentFrequency);\n  const periodicRate = annualInterestRate / 100 / periodsPerYear;\n  \n  let balance = principal;\n  let month = 0;\n  let totalInterest = 0;\n  const timeSeriesData = [];\n  \n  // Add initial data point\n  timeSeriesData.push({ month: 0, balance });\n  \n  while (balance > 0 && month < 1200) { // Cap at 100 years (1200 months) to prevent infinite loops\n    month++;\n    \n    // Calculate interest for this period\n    const interestForPeriod = balance * periodicRate;\n    totalInterest += interestForPeriod;\n    \n    // Add interest to balance\n    balance += interestForPeriod;\n    \n    // Subtract payment (regular + additional)\n    const totalPayment = Math.min(paymentAmount + additionalPayment, balance);\n    balance -= totalPayment;\n    \n    // Add data point for chart\n    if (month % Math.ceil(12 / periodsPerYear) === 0 || balance <= 0) {\n      timeSeriesData.push({ month, balance });\n    }\n  }\n  \n  return { months: month, totalInterest, timeSeriesData };\n};\n\n// Helper function to get periods per year based on frequency\nconst getPeriodsPerYear = (frequency: string): number => {\n  switch (frequency) {\n    case 'weekly': return 52;\n    case 'bi-weekly': return 26;\n    case 'monthly': return 12;\n    case 'quarterly': return 4;\n    case 'annually': return 1;\n    default: return 12;\n  }\n};\n```\n\nImplement similar functions for investment growth calculations and comparison logic.",
        "testStrategy": "Write comprehensive unit tests for each calculation function. Test with various input values, including edge cases. Verify that calculations are accurate by comparing results with known financial formulas. Test with extreme values to ensure the functions handle them gracefully. Benchmark performance for large time series calculations.",
        "priority": "high",
        "dependencies": [
          22
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Implement Chart Visualization",
        "description": "Create the dual-line chart visualization that shows debt balance and investment balance over time, with highlighted crossover and coverage points.",
        "details": "Create a `components/Chart.tsx` component using Chart.js with react-chartjs-2. The chart should display two lines:\n\n1. Debt balance over time\n2. Investment balance over time\n\nHighlight key milestones:\n- Crossover point (when investment balance surpasses debt balance)\n- Coverage point (when investment returns cover debt payments)\n\n```tsx\nimport { Line } from 'react-chartjs-2';\nimport {\n  Chart as ChartJS,\n  CategoryScale,\n  LinearScale,\n  PointElement,\n  LineElement,\n  Title,\n  Tooltip,\n  Legend,\n  ChartOptions,\n  ChartData\n} from 'chart.js';\n\nChartJS.register(\n  CategoryScale,\n  LinearScale,\n  PointElement,\n  LineElement,\n  Title,\n  Tooltip,\n  Legend\n);\n\ninterface ChartProps {\n  debtData: number[];\n  investmentData: number[];\n  labels: string[];\n  crossoverPoint?: number;\n  coveragePoint?: number;\n}\n\nconst Chart = ({ debtData, investmentData, labels, crossoverPoint, coveragePoint }: ChartProps) => {\n  // Create annotations for crossover and coverage points\n  const annotations: any = {};\n  \n  if (crossoverPoint !== undefined && crossoverPoint >= 0) {\n    annotations.crossover = {\n      type: 'line',\n      mode: 'vertical',\n      scaleID: 'x',\n      value: crossoverPoint,\n      borderColor: 'rgba(75, 192, 192, 0.6)',\n      borderWidth: 2,\n      label: {\n        content: 'Crossover Point',\n        enabled: true,\n        position: 'top'\n      }\n    };\n  }\n  \n  if (coveragePoint !== undefined && coveragePoint >= 0) {\n    annotations.coverage = {\n      type: 'line',\n      mode: 'vertical',\n      scaleID: 'x',\n      value: coveragePoint,\n      borderColor: 'rgba(153, 102, 255, 0.6)',\n      borderWidth: 2,\n      label: {\n        content: 'Coverage Point',\n        enabled: true,\n        position: 'bottom'\n      }\n    };\n  }\n\n  const options: ChartOptions<'line'> = {\n    responsive: true,\n    maintainAspectRatio: false,\n    plugins: {\n      legend: {\n        position: 'top',\n      },\n      title: {\n        display: true,\n        text: 'Debt vs Investment Over Time',\n      },\n      annotation: {\n        annotations\n      }\n    },\n    scales: {\n      y: {\n        beginAtZero: true,\n        ticks: {\n          callback: (value) => `$${value.toLocaleString()}`\n        }\n      }\n    }\n  };\n\n  const data: ChartData<'line'> = {\n    labels,\n    datasets: [\n      {\n        label: 'Debt Balance',\n        data: debtData,\n        borderColor: 'rgb(255, 99, 132)',\n        backgroundColor: 'rgba(255, 99, 132, 0.5)',\n      },\n      {\n        label: 'Investment Balance',\n        data: investmentData,\n        borderColor: 'rgb(53, 162, 235)',\n        backgroundColor: 'rgba(53, 162, 235, 0.5)',\n      },\n    ],\n  };\n\n  return (\n    <div className=\"h-96 w-full\">\n      <Line options={options} data={data} />\n    </div>\n  );\n};\n\nexport default Chart;\n```\n\nEnsure the chart is responsive and handles various data scenarios gracefully.",
        "testStrategy": "Test the Chart component with various data sets to ensure it renders correctly. Verify that crossover and coverage points are highlighted properly. Test responsiveness on different screen sizes. Test with edge cases like no data, very large data sets, or when crossover/coverage points don't exist. Verify that tooltips and legends are displayed correctly.",
        "priority": "high",
        "dependencies": [
          23
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "Implement Results and Recommendation Section",
        "description": "Create the results section that displays the chart visualization and provides a clear recommendation on whether to invest or pay off debt.",
        "details": "Implement the ResultsSection component that:\n\n1. Displays the dual-line chart\n2. Shows a clear recommendation statement\n3. Includes a \"Not financial advice\" disclaimer\n4. Provides additional context about the recommendation\n\n```tsx\nimport Chart from './Chart';\nimport { useCalculator } from '../context/CalculatorContext';\n\nconst ResultsSection = () => {\n  const { state } = useCalculator();\n  const { results } = state;\n  \n  if (!results.chartData) {\n    return (\n      <div className=\"mt-8 p-6 bg-gray-50 rounded-lg shadow-md\">\n        <p className=\"text-center text-gray-500\">Enter your financial information above to see results</p>\n      </div>\n    );\n  }\n  \n  return (\n    <div className=\"mt-8 p-6 bg-white rounded-lg shadow-md\">\n      <h2 className=\"text-2xl font-semibold mb-4\">Results</h2>\n      \n      {/* Recommendation */}\n      <div className=\"mb-6 p-4 bg-blue-50 rounded-lg\">\n        <h3 className=\"text-xl font-medium mb-2\">Recommendation</h3>\n        <p className=\"text-lg font-bold mb-1\">{results.recommendation}</p>\n        <p className=\"text-xs text-gray-500\">* This is not financial advice. Please consult with a financial advisor before making investment decisions.</p>\n      </div>\n      \n      {/* Chart */}\n      <div className=\"mb-6\">\n        <Chart \n          debtData={results.chartData.debtData}\n          investmentData={results.chartData.investmentData}\n          labels={results.chartData.labels}\n          crossoverPoint={results.crossoverPoint}\n          coveragePoint={results.coveragePoint}\n        />\n      </div>\n      \n      {/* Key Insights */}\n      <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n        {results.crossoverPoint !== null && (\n          <div className=\"p-3 bg-green-50 rounded\">\n            <h4 className=\"font-medium\">Crossover Point</h4>\n            <p>Your investment would surpass your debt in {results.crossoverPoint} months.</p>\n          </div>\n        )}\n        {results.coveragePoint !== null && (\n          <div className=\"p-3 bg-purple-50 rounded\">\n            <h4 className=\"font-medium\">Coverage Point</h4>\n            <p>Investment returns could cover your debt payments in {results.coveragePoint} months.</p>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default ResultsSection;\n```\n\nEnsure the recommendation is clear and easy to understand, with appropriate context to help users make informed decisions.",
        "testStrategy": "Test the ResultsSection component with various result scenarios. Verify that the recommendation text is displayed correctly. Test the empty state when no calculations have been performed. Verify that the disclaimer is always visible. Test that key insights are displayed correctly when available and hidden when not applicable.",
        "priority": "medium",
        "dependencies": [
          24
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "Implement Real-time Calculation Updates",
        "description": "Create a mechanism to trigger calculations and update results in real-time as users modify input values.",
        "details": "Implement a useEffect hook in the main App component that triggers calculations whenever input values change. Create an action creator and reducer case to update the results in the global state.\n\n```tsx\n// In App.tsx or a custom hook\nimport { useEffect } from 'react';\nimport { useCalculator } from './context/CalculatorContext';\nimport { calculateDebtPayoff, calculateInvestmentGrowth, determineOptimalStrategy } from './utils/calculations';\n\nconst useCalculationEffect = () => {\n  const { state, dispatch } = useCalculator();\n  const { debtInfo, investmentInfo, cashFlowInfo } = state;\n  \n  useEffect(() => {\n    // Skip calculation if essential values are missing or zero\n    if (\n      debtInfo.amount <= 0 ||\n      debtInfo.interestRate <= 0 ||\n      debtInfo.paymentAmount <= 0 ||\n      cashFlowInfo.amount <= 0\n    ) {\n      return;\n    }\n    \n    // Calculate debt payoff with and without additional payments\n    const regularDebtPayoff = calculateDebtPayoff(\n      debtInfo.amount,\n      debtInfo.interestRate,\n      debtInfo.paymentAmount,\n      debtInfo.paymentFrequency\n    );\n    \n    const acceleratedDebtPayoff = calculateDebtPayoff(\n      debtInfo.amount,\n      debtInfo.interestRate,\n      debtInfo.paymentAmount,\n      debtInfo.paymentFrequency,\n      getAnnualizedAmount(cashFlowInfo.amount, cashFlowInfo.frequency) / 12\n    );\n    \n    // Calculate investment growth\n    const investmentGrowth = calculateInvestmentGrowth(\n      investmentInfo.amount,\n      investmentInfo.expectedReturn,\n      getAnnualizedAmount(cashFlowInfo.amount, cashFlowInfo.frequency),\n      Math.ceil(acceleratedDebtPayoff.months / 12) * 12 // Round up to nearest year\n    );\n    \n    // Determine optimal strategy\n    const { recommendation, crossoverPoint, coveragePoint } = determineOptimalStrategy(\n      acceleratedDebtPayoff,\n      investmentGrowth,\n      debtInfo.paymentAmount\n    );\n    \n    // Prepare chart data\n    const chartData = {\n      labels: generateLabels(Math.max(acceleratedDebtPayoff.months, investmentGrowth.months)),\n      debtData: acceleratedDebtPayoff.timeSeriesData.map(d => d.balance),\n      investmentData: investmentGrowth.timeSeriesData.map(d => d.balance)\n    };\n    \n    // Update results in state\n    dispatch({\n      type: 'UPDATE_RESULTS',\n      payload: {\n        recommendation,\n        chartData,\n        crossoverPoint,\n        coveragePoint\n      }\n    });\n  }, [debtInfo, investmentInfo, cashFlowInfo, dispatch]);\n};\n\n// Helper function to convert different frequencies to annual amount\nconst getAnnualizedAmount = (amount: number, frequency: string): number => {\n  switch (frequency) {\n    case 'lump-sum': return amount;\n    case 'weekly': return amount * 52;\n    case 'bi-weekly': return amount * 26;\n    case 'monthly': return amount * 12;\n    case 'quarterly': return amount * 4;\n    case 'annually': return amount;\n    default: return amount * 12;\n  }\n};\n\n// Helper function to generate month labels\nconst generateLabels = (months: number): string[] => {\n  return Array.from({ length: Math.ceil(months / 12) + 1 }, (_, i) => `Year ${i}`);\n};\n```\n\nEnsure calculations are debounced to prevent performance issues with rapid input changes.",
        "testStrategy": "Test the calculation effect with various input scenarios. Verify that calculations are triggered when inputs change. Test debouncing to ensure performance is maintained with rapid input changes. Verify that the results state is updated correctly after calculations. Test edge cases like very large or very small input values.",
        "priority": "high",
        "dependencies": [
          23,
          25
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Implement Input Validation and Error Handling",
        "description": "Add comprehensive input validation and error handling to ensure users enter valid data and receive helpful error messages.",
        "details": "Implement the following validation features:\n\n1. Real-time validation as users type\n2. Helpful error messages for invalid inputs\n3. Prevent calculations with invalid or incomplete data\n\nCreate a validation utility file `utils/validation.ts`:\n\n```typescript\nimport { z } from 'zod';\nimport { DebtInfo, InvestmentInfo, CashFlowInfo } from '../types';\n\n// Validation schemas\nexport const debtInfoSchema = z.object({\n  amount: z.number().positive('Debt amount must be greater than zero'),\n  interestRate: z.number().min(0, 'Interest rate cannot be negative').max(100, 'Interest rate cannot exceed 100%'),\n  paymentFrequency: z.enum(['weekly', 'bi-weekly', 'monthly', 'quarterly', 'annually']),\n  paymentAmount: z.number().positive('Payment amount must be greater than zero'),\n  timeRemaining: z.number().int().positive('Time remaining must be a positive integer')\n});\n\nexport const investmentInfoSchema = z.object({\n  amount: z.number().min(0, 'Investment amount cannot be negative'),\n  expectedReturn: z.number().min(0, 'Expected return cannot be negative').max(100, 'Expected return cannot exceed 100%')\n});\n\nexport const cashFlowInfoSchema = z.object({\n  frequency: z.enum(['lump-sum', 'weekly', 'bi-weekly', 'monthly', 'quarterly', 'annually']),\n  amount: z.number().positive('Cash flow amount must be greater than zero')\n});\n\n// Validation functions\nexport const validateDebtInfo = (data: DebtInfo): { valid: boolean; errors: Record<string, string> } => {\n  try {\n    debtInfoSchema.parse(data);\n    return { valid: true, errors: {} };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      const errors: Record<string, string> = {};\n      error.errors.forEach(err => {\n        const path = err.path.join('.');\n        errors[path] = err.message;\n      });\n      return { valid: false, errors };\n    }\n    return { valid: false, errors: { _general: 'Invalid data' } };\n  }\n};\n\n// Similar functions for investment and cash flow validation\n```\n\nIntegrate validation with the form components and display error messages inline with the inputs.",
        "testStrategy": "Test validation functions with valid and invalid inputs. Verify that appropriate error messages are generated for different types of validation failures. Test that the UI displays error messages correctly. Verify that calculations are not performed with invalid data. Test edge cases like extremely large values or special characters in numeric fields.",
        "priority": "medium",
        "dependencies": [
          19,
          20,
          21,
          22
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Implement Responsive Design and Mobile Optimization",
        "description": "Ensure the application is fully responsive and provides an optimal user experience across desktop, tablet, and mobile devices.",
        "details": "Implement responsive design using Tailwind CSS breakpoints. Optimize the layout for different screen sizes:\n\n1. Desktop: Three-column layout with sections side by side\n2. Tablet: Two-column layout\n3. Mobile: Single-column layout with sections stacked vertically\n\nOptimize touch interactions for mobile users:\n\n```tsx\n// Example responsive container in AppContainer.tsx\nconst AppContainer = () => {\n  return (\n    <div className=\"container mx-auto px-4 py-8\">\n      <h1 className=\"text-3xl font-bold mb-8 text-center\">Invest vs Debt Calculator</h1>\n      \n      {/* Responsive grid layout */}\n      <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6\">\n        <DebtSection />\n        <InvestmentSection />\n        <CashFlowSection />\n      </div>\n      \n      <ResultsSection />\n    </div>\n  );\n};\n```\n\nOptimize input fields for touch devices:\n\n```css\n/* In your global CSS or Tailwind config */\n@layer utilities {\n  .touch-input {\n    @apply py-3 px-4;\n  }\n}\n```\n\n```tsx\n// Example optimized input component\nconst CurrencyInput = ({ label, value, onChange, error, placeholder }: CurrencyInputProps) => {\n  return (\n    <div className=\"mb-4\">\n      <label className=\"block text-sm font-medium mb-1\">{label}</label>\n      <div className=\"relative\">\n        <span className=\"absolute left-3 top-1/2 transform -translate-y-1/2\">$</span>\n        <input\n          type=\"text\"\n          className={`pl-6 w-full p-2 md:p-3 border rounded ${error ? 'border-red-500' : 'border-gray-300'} text-base md:text-lg`}\n          value={value === 0 ? '' : value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}\n          onChange={handleChange}\n          placeholder={placeholder}\n        />\n      </div>\n      {error && <p className=\"text-red-500 text-xs mt-1\">{error}</p>}\n    </div>\n  );\n};\n```\n\nOptimize the chart for different screen sizes:\n\n```tsx\n// In Chart.tsx\nconst options: ChartOptions<'line'> = {\n  responsive: true,\n  maintainAspectRatio: false,\n  plugins: {\n    legend: {\n      position: window.innerWidth < 768 ? 'bottom' : 'top',\n      labels: {\n        boxWidth: window.innerWidth < 768 ? 10 : 40,\n        font: {\n          size: window.innerWidth < 768 ? 10 : 12\n        }\n      }\n    },\n    // ... other plugin options\n  },\n  // ... other options\n};\n```",
        "testStrategy": "Test the application on various devices and screen sizes. Verify that the layout adapts appropriately to different screen widths. Test touch interactions on mobile devices. Verify that input fields are easily usable on touch screens. Test the chart visibility and usability on small screens. Verify that all content is accessible and readable on mobile devices.",
        "priority": "medium",
        "dependencies": [
          17,
          18,
          24,
          25
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "Implement Accessibility Features",
        "description": "Ensure the application is accessible to all users, including those with disabilities, by implementing WCAG compliance features.",
        "details": "Implement the following accessibility features:\n\n1. Proper semantic HTML structure\n2. ARIA attributes for interactive elements\n3. Keyboard navigation support\n4. Screen reader compatibility\n5. Sufficient color contrast\n6. Focus management\n\nExample implementations:\n\n```tsx\n// Example accessible input component\nconst CurrencyInput = ({ id, label, value, onChange, error, placeholder }: CurrencyInputProps & { id: string }) => {\n  const inputId = `${id}-input`;\n  const errorId = `${id}-error`;\n  \n  return (\n    <div className=\"mb-4\">\n      <label htmlFor={inputId} className=\"block text-sm font-medium mb-1\">{label}</label>\n      <div className=\"relative\">\n        <span className=\"absolute left-3 top-1/2 transform -translate-y-1/2\" aria-hidden=\"true\">$</span>\n        <input\n          id={inputId}\n          type=\"text\"\n          className={`pl-6 w-full p-2 border rounded ${error ? 'border-red-500' : 'border-gray-300'}`}\n          value={value === 0 ? '' : value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}\n          onChange={handleChange}\n          placeholder={placeholder}\n          aria-describedby={error ? errorId : undefined}\n          aria-invalid={!!error}\n        />\n      </div>\n      {error && <p id={errorId} className=\"text-red-500 text-xs mt-1\">{error}</p>}\n    </div>\n  );\n};\n```\n\nImplement keyboard navigation for the form:\n\n```tsx\n// In App.tsx or a custom hook\nconst useKeyboardNavigation = () => {\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      // Handle tab navigation\n      if (e.key === 'Tab') {\n        // Custom tab navigation logic if needed\n      }\n      \n      // Handle enter key for form submission\n      if (e.key === 'Enter' && e.target instanceof HTMLInputElement) {\n        const form = e.target.form;\n        const index = Array.prototype.indexOf.call(form, e.target);\n        form.elements[index + 1].focus();\n        e.preventDefault();\n      }\n    };\n    \n    document.addEventListener('keydown', handleKeyDown);\n    return () => document.removeEventListener('keydown', handleKeyDown);\n  }, []);\n};\n```\n\nAdd a skip link for keyboard users:\n\n```tsx\n// In App.tsx\nconst App = () => {\n  return (\n    <>\n      <a href=\"#main-content\" className=\"sr-only focus:not-sr-only focus:absolute focus:p-4 focus:bg-white focus:z-50\">\n        Skip to main content\n      </a>\n      <main id=\"main-content\">\n        <AppContainer />\n      </main>\n    </>\n  );\n};\n```\n\nEnsure sufficient color contrast for all text and UI elements.",
        "testStrategy": "Test with screen readers to verify that all content is properly announced. Test keyboard navigation to ensure all interactive elements are accessible without a mouse. Verify that form validation errors are properly communicated to screen readers. Test color contrast using accessibility tools. Validate against WCAG 2.1 AA standards using automated testing tools like axe-core.",
        "priority": "medium",
        "dependencies": [
          17,
          18,
          24,
          25,
          28
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Implement Performance Optimizations",
        "description": "Optimize the application for performance, ensuring smooth interactions and efficient rendering, especially for complex calculations and chart updates.",
        "details": "Implement the following performance optimizations:\n\n1. Memoization of expensive calculations using useMemo and useCallback\n2. Debouncing of input changes to prevent excessive re-renders\n3. Code splitting for larger components\n4. Optimized chart rendering\n\nExample implementations:\n\n```tsx\n// Debounce input changes\nimport { useState, useEffect, useCallback } from 'react';\nimport debounce from 'lodash.debounce';\n\nconst useDebounce = (value: any, delay: number) => {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  \n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n    \n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n  \n  return debouncedValue;\n};\n\n// In a component\nconst DebtSection = () => {\n  const { state, dispatch } = useCalculator();\n  const [localDebtInfo, setLocalDebtInfo] = useState(state.debtInfo);\n  \n  const debouncedDebtInfo = useDebounce(localDebtInfo, 300);\n  \n  useEffect(() => {\n    dispatch({ type: 'UPDATE_DEBT_INFO', payload: debouncedDebtInfo });\n  }, [debouncedDebtInfo, dispatch]);\n  \n  // Rest of component\n};\n```\n\nMemoize expensive calculations:\n\n```tsx\n// In calculation hook\nconst useCalculations = () => {\n  const { state } = useCalculator();\n  const { debtInfo, investmentInfo, cashFlowInfo } = state;\n  \n  const debtPayoff = useMemo(() => {\n    if (debtInfo.amount <= 0 || debtInfo.interestRate <= 0 || debtInfo.paymentAmount <= 0) {\n      return null;\n    }\n    \n    return calculateDebtPayoff(\n      debtInfo.amount,\n      debtInfo.interestRate,\n      debtInfo.paymentAmount,\n      debtInfo.paymentFrequency\n    );\n  }, [debtInfo.amount, debtInfo.interestRate, debtInfo.paymentAmount, debtInfo.paymentFrequency]);\n  \n  // Similar memoization for other calculations\n  \n  return { debtPayoff, /* other results */ };\n};\n```\n\nOptimize chart rendering:\n\n```tsx\n// In Chart.tsx\nconst MemoizedChart = React.memo(Chart, (prevProps, nextProps) => {\n  // Custom comparison function to prevent unnecessary re-renders\n  return (\n    prevProps.debtData.length === nextProps.debtData.length &&\n    prevProps.investmentData.length === nextProps.investmentData.length &&\n    prevProps.crossoverPoint === nextProps.crossoverPoint &&\n    prevProps.coveragePoint === nextProps.coveragePoint\n  );\n});\n\nexport default MemoizedChart;\n```\n\nImplement code splitting for larger components:\n\n```tsx\n// In App.tsx\nimport React, { lazy, Suspense } from 'react';\n\nconst ResultsSection = lazy(() => import('./components/ResultsSection'));\n\nconst App = () => {\n  return (\n    <div className=\"app\">\n      <AppContainer>\n        <DebtSection />\n        <InvestmentSection />\n        <CashFlowSection />\n        <Suspense fallback={<div className=\"loading\">Loading results...</div>}>\n          <ResultsSection />\n        </Suspense>\n      </AppContainer>\n    </div>\n  );\n};\n```",
        "testStrategy": "Benchmark performance before and after optimizations. Test with large datasets to verify that calculations remain efficient. Measure render times for components, especially after input changes. Test debouncing to ensure it prevents excessive re-renders without affecting user experience. Verify that code splitting works correctly and improves initial load time.",
        "priority": "low",
        "dependencies": [
          23,
          24,
          26
        ],
        "status": "done",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-27T16:56:09.893Z",
      "updated": "2025-07-27T18:14:37.105Z",
      "description": "Tasks for master context"
    }
  }
}